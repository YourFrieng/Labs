#include"list.h"


void List::Add(char x)
{
	list* temp = new list;               //Выделение памяти под новый элемент структуры
	temp->Next = NULL;                   //Указываем, что изначально по следующему адресу пусто
	temp->x = x;                         //Записываем значение в структуру

	if (Head != NULL)                    //Если список не пуст
	{
		temp->Prev = Tail;               //Указываем адрес на предыдущий элемент в соотв. поле
		Tail->Next = temp;               //Указываем адрес следующего за хвостом элемента
		Tail = temp;                     //Меняем адрес хвоста
	}
	else //Если список пустой
	{
		temp->Prev = NULL;               //Предыдущий элемент указывает в пустоту
		Head = Tail = temp;              //Голова=Хвост=тот элемент, что сейчас добавили
	}
}


void List::Show()
{
	//ВЫВОДИМ СПИСОК С КОНЦА
	list* temp = Tail;                   //Временный указатель на адрес последнего элемента
	if (Head != NULL) {
		cout << "Список з кiнця:" << endl;
		while (temp != NULL)               //Пока не встретится пустое значение
		{
			cout << temp->x << " ";        //Выводить значение на экран
			temp = temp->Prev;             //Указываем, что нужен адрес предыдущего элемента
		}
		cout << endl;

		//ВЫВОДИМ СПИСОК С НАЧАЛА
		temp = Head;                       //Временно указываем на адрес первого элемента
		cout << "Список з початку:" << endl;
		while (temp != NULL)              //Пока не встретим пустое значение
		{
			cout << temp->x << " ";        //Выводим каждое считанное значение на экран
			temp = temp->Next;             //Смена адреса на адрес следующего элемента
		}
		cout << endl;
	}

}
void List::WriteInFile()
{
	//ВЫВОДИМ СПИСОК С КОНЦА
	list* temp = Tail;                   //Временный указатель на адрес последнего элемента
	ofstream file_out("output.txt");
	if (file_out.good()) {
		if (Head != NULL) {
			file_out << "Список з кiнця:" << endl;
			while (temp != NULL)               //Пока не встретится пустое значение
			{
				file_out << temp->x << " ";        //Выводить значение на экран
				temp = temp->Prev;             //Указываем, что нужен адрес предыдущего элемента
			}
			file_out << endl;

			//ВЫВОДИМ СПИСОК С НАЧАЛА
			temp = Head;                       //Временно указываем на адрес первого элемента
			file_out << "Список з початку:" << endl;
			while (temp != NULL)              //Пока не встретим пустое значение
			{
				file_out << temp->x << " ";        //Выводим каждое считанное значение на экран
				temp = temp->Next;             //Смена адреса на адрес следующего элемента
			}
			file_out << endl;
		}
	}
}
void List::If_NULL() {
	if (Head != NULL) {					//Проверка на пустоту списка
		cout << "Список не пустий" << endl;
	}
	else {
		cout << "Список пустий!" << endl;
	}
}

void List::ShowASCII() {
	if ((Head != NULL) && (Head->Next != NULL)) {
		list* temp = Tail;
		int asci_cod = (int)temp->x;
		cout << "ASCII код останнього елементу: " << asci_cod << endl;
		asci_cod = (int)(temp->Prev->x);
		cout << "ASCII код передостаннього елементу: " << asci_cod << endl;
	}
	else {
		cout << "У списку менше нiж 2 елементи" << endl;
	}
}

void List::Sort() {
	if ((Head != NULL) && (Head->Next != NULL)) {
		list* first = Head;
		list* second = Head->Next;
		list* temp = new list;              //Временное звено для хранения переставляемого всех значений переставляемого звена

		while (first->Next) {                 //Обходим по всем звеньям, за исключением крайнего правого
			while (second) {              //Обходим по всем звеньям, включая крайний правый (по всем относительно первого левого на текущий момент)
				if ((first->x) < (second->x)) {        //Проверяем необходимость перестановки
					temp->x = first->x;              //И переставляем все внутренние элементы, за исключением указателей связи, местами
					first->x = second->x;             //Сейчас у нас имеется только x, поэтому только его
					second->x = temp->x;             //иначе бы  нужно было это проделывать для каждого несвязующего элемента
				}
				second = second->Next;                    //не забываем направлять указатель на следующий элемент (по подобию инкремента), иначе цикл зависнет
			}

			first = first->Next;                              //не забываем направлять указатель на следующий элемент (по подобию инкремента), иначе цикл зависнет
			second = first->Next;                             //Поскольку второй указатель убежал немного вперёд, обязательно возвращаем его назад, это следующий элемент относительно текущего первого
		}

	}
}

